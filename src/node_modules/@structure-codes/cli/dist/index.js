#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const buildStructure_1 = require("./buildStructure");
const generateTree_1 = require("./generateTree");
// @ts-ignore
const package_json_1 = __importDefault(require("../package.json"));
const checkConfig_1 = require("./utils/checkConfig");
(() => __awaiter(void 0, void 0, void 0, function* () {
    const program = new commander_1.Command();
    program.version(package_json_1.default.version, "-v, --version");
    // tree cli does 2 things
    // - Generate structure or .tree file from existing directory structure
    // - Use .tree file to build directory structure
    const collect = (value, previous) => {
        return previous.concat([value]);
    };
    // Check if config already exists, if not attempt to create it
    yield (0, checkConfig_1.checkConfig)();
    program
        .argument("[directory]", "directory to build structure from", ".")
        .option("-o, --output <output>", "location where command output should be stored")
        // TODO: plz fix thx
        // .option("-d, --depth <depth>", "depth to search within the target directory")
        .option("-i, --ignore <ignore>", "ignore these patterns", collect, [])
        .option("-c, --config-ignore", "include patterns that are ignored by config")
        .option("-d, --dir-only", "ignore files in tree output")
        .option("-j, --json", "print tree in json format")
        .option("-e, --editor", "open structure in new vscode window")
        .option("-s, --silent", "do not print anything to the console")
        .action((directory, options) => {
        (0, generateTree_1.generateTree)(directory, options);
    });
    // result is newly created dirs
    program
        .command("build")
        .argument("<file>", ".tree file to build structure from")
        .argument("[output]", "output directory to build structure in", ".")
        .action((file, output) => {
        (0, buildStructure_1.buildStructure)(file, output);
    });
    program.addHelpText('afterAll', `
  Examples:
    Output tree ignoring dist to file new.tree
    $ struct -i dist -o new.tree
    
    Build structure from src.tree in directory new-project
    $ struct build ./src.tree new-project
  `);
    program.parse(process.argv);
}))();
//# sourceMappingURL=index.js.map